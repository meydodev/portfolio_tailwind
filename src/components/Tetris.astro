<!-- Bot√≥n para abrir modal -->
<div class="flex justify-center my-10 hidden">
  <button id="openModal" class="bg-purple-600 text-white px-6 py-2 rounded hover:bg-purple-700 transition">
    Jugar Tetris
  </button>
</div>

<!-- Modal -->
<div id="tetrisModal" class="fixed inset-0 bg-black/50 flex justify-center items-center hidden z-50">
  <div class="relative bg-gray-200 dark:bg-gray-900 p-4 rounded shadow-lg w-72 h-[560px]">

    <!-- Bot√≥n cerrar -->
    <button id="closeModal"
      class="absolute top-2 right-2 text-black dark:text-white text-xl hover:scale-110 transition z-50">
      ‚úñÔ∏è
    </button>

    <!-- Puntuaci√≥n -->
    <div class="text-center mb-2 text-black dark:text-white font-bold">
      Puntuaci√≥n: <span id="score">0</span>
    </div>

    <!-- Nivel -->
    <div class="text-center mb-2 text-black dark:text-white font-bold">
      Nivel: <span id="level">1</span>
    </div>

    <!-- Contenedor canvas -->
    <div id="tetrisContainer" class="relative w-64 h-100 mx-auto border border-gray-300 rounded overflow-hidden mb-2">
      <!-- Aqu√≠ se insertar√° el canvas din√°micamente -->
    </div>

    <!-- Controles t√°ctiles -->
    <div class="flex justify-center gap-2 mb-2">
      <button id="btnLeft" class="bg-purple-500 text-white px-2 py-1 rounded">‚¨ÖÔ∏è</button>
      <button id="btnRight" class="bg-purple-500 text-white px-2 py-1 rounded">‚û°Ô∏è</button>
      <button id="btnRotate" class="bg-purple-500 text-white px-2 py-1 rounded">‚§æ/‚¨ÜÔ∏è</button>
      <button id="btnDown" class="bg-purple-500 text-white px-2 py-1 rounded">‚¨áÔ∏è</button>
      <button id="btnReset" class="bg-red-500 text-white px-2 py-1 rounded">üîÑ</button>
    </div>

<script type="module">
class Point { constructor(x, y) { this.x = x; this.y = y; } }
class Shape {
  points = []; rotation = 0; fillColor = '';
  move(x, y) { return this.points.map(p => new Point(p.x + x, p.y + y)); }
  setPos(newPoints) { this.points = newPoints; }
  drop() { return this.move(0, 1); }
  moveLeft() { return this.move(-1, 0); }
  moveRight() { return this.move(1, 0); }
  rotate(clockwise) { throw new Error('Abstract method'); }
}

// T
class TShape extends Shape {
  constructor(cols) {
    super();
    this.fillColor = "purple";
    const x = Math.floor(cols / 2), y = -2;
    this.points.push(new Point(x - 1, y), new Point(x, y), new Point(x + 1, y), new Point(x, y + 1));
  }
  rotate(clockwise) {
    this.rotation = (this.rotation + (clockwise ? 1 : -1) + 4) % 4;
    const p = this.points[1];
    switch (this.rotation) {
      case 0: return [new Point(p.x - 1, p.y), p, new Point(p.x + 1, p.y), new Point(p.x, p.y + 1)];
      case 1: return [new Point(p.x, p.y - 1), p, new Point(p.x, p.y + 1), new Point(p.x - 1, p.y)];
      case 2: return [new Point(p.x + 1, p.y), p, new Point(p.x - 1, p.y), new Point(p.x, p.y - 1)];
      case 3: return [new Point(p.x, p.y + 1), p, new Point(p.x, p.y - 1), new Point(p.x + 1, p.y)];
    }
  }
}

// I
class IShape extends Shape {
  constructor(cols) {
    super();
    this.fillColor = "cyan";
    const x = Math.floor(cols / 2), y = -2;
    this.points.push(new Point(x - 2, y), new Point(x - 1, y), new Point(x, y), new Point(x + 1, y));
  }
  rotate(clockwise) {
    this.rotation = (this.rotation + (clockwise ? 1 : -1) + 4) % 4;
    const p = this.points[2];
    return this.rotation % 2 === 0
      ? [new Point(p.x - 2, p.y), new Point(p.x - 1, p.y), p, new Point(p.x + 1, p.y)]
      : [new Point(p.x, p.y - 2), new Point(p.x, p.y - 1), p, new Point(p.x, p.y + 1)];
  }
}

// O
class OShape extends Shape {
  constructor(cols) {
    super();
    this.fillColor = "yellow";
    const x = Math.floor(cols / 2), y = -2;
    this.points.push(new Point(x, y), new Point(x + 1, y), new Point(x, y + 1), new Point(x + 1, y + 1));
  }
  rotate() { return this.points; }
}

// L
class LShape extends Shape {
  constructor(cols) {
    super();
    this.fillColor = "orange";
    const x = Math.floor(cols / 2), y = -2;
    this.points.push(new Point(x - 1, y), new Point(x, y), new Point(x + 1, y), new Point(x + 1, y + 1));
  }
  rotate(clockwise) {
    this.rotation = (this.rotation + (clockwise ? 1 : -1) + 4) % 4;
    const p = this.points[1];
    switch (this.rotation) {
      case 0: return [new Point(p.x - 1, p.y), p, new Point(p.x + 1, p.y), new Point(p.x + 1, p.y + 1)];
      case 1: return [new Point(p.x, p.y - 1), p, new Point(p.x, p.y + 1), new Point(p.x - 1, p.y + 1)];
      case 2: return [new Point(p.x + 1, p.y), p, new Point(p.x - 1, p.y), new Point(p.x - 1, p.y - 1)];
      case 3: return [new Point(p.x, p.y + 1), p, new Point(p.x, p.y - 1), new Point(p.x + 1, p.y - 1)];
    }
  }
}

// J
class JShape extends Shape {
  constructor(cols) {
    super();
    this.fillColor = "blue";
    const x = Math.floor(cols / 2), y = -2;
    this.points.push(new Point(x - 1, y), new Point(x, y), new Point(x + 1, y), new Point(x - 1, y + 1));
  }
  rotate(clockwise) {
    this.rotation = (this.rotation + (clockwise ? 1 : -1) + 4) % 4;
    const p = this.points[1];
    switch (this.rotation) {
      case 0: return [new Point(p.x - 1, p.y), p, new Point(p.x + 1, p.y), new Point(p.x - 1, p.y + 1)];
      case 1: return [new Point(p.x, p.y - 1), p, new Point(p.x, p.y + 1), new Point(p.x - 1, p.y - 1)];
      case 2: return [new Point(p.x + 1, p.y), p, new Point(p.x - 1, p.y), new Point(p.x + 1, p.y - 1)];
      case 3: return [new Point(p.x, p.y + 1), p, new Point(p.x, p.y - 1), new Point(p.x + 1, p.y + 1)];
    }
  }
}

// S
class SShape extends Shape {
  constructor(cols) {
    super();
    this.fillColor = "green";
    const x = Math.floor(cols / 2), y = -2;
    this.points.push(new Point(x, y), new Point(x + 1, y), new Point(x - 1, y + 1), new Point(x, y + 1));
  }
  rotate(clockwise) {
    this.rotation = (this.rotation + (clockwise ? 1 : -1) + 4) % 4;
    const p = this.points[0];
    return this.rotation % 2 === 0
      ? [p, new Point(p.x + 1, p.y), new Point(p.x - 1, p.y + 1), new Point(p.x, p.y + 1)]
      : [p, new Point(p.x, p.y + 1), new Point(p.x + 1, p.y - 1), new Point(p.x + 1, p.y)];
  }
}

// Z
class ZShape extends Shape {
  constructor(cols) {
    super();
    this.fillColor = "red";
    const x = Math.floor(cols / 2), y = -2;
    this.points.push(new Point(x - 1, y), new Point(x, y), new Point(x, y + 1), new Point(x + 1, y + 1));
  }
  rotate(clockwise) {
    this.rotation = (this.rotation + (clockwise ? 1 : -1) + 4) % 4;
    const p = this.points[1];
    return this.rotation % 2 === 0
      ? [new Point(p.x - 1, p.y), p, new Point(p.x, p.y + 1), new Point(p.x + 1, p.y + 1)]
      : [new Point(p.x, p.y - 1), p, new Point(p.x - 1, p.y), new Point(p.x - 1, p.y + 1)];
  }
}

class Grid {
  constructor(rows, cols, blockSize, backColor, canvas) {
    this.rows = rows; this.cols = cols; this.blockSize = blockSize; this.backColor = backColor;
    this.canvas = canvas; this.ctx = canvas.getContext('2d');
    this.blockColor = Array.from({ length: rows }, () => Array(cols).fill(backColor));
  }
  paintSquare(row, col, color) {
    if (row >= 0) {
      this.ctx.fillStyle = color;
      this.ctx.fillRect(col * this.blockSize, row * this.blockSize, this.blockSize, this.blockSize);
    }
  }
  eraseGrid() { this.ctx.fillStyle = this.backColor; this.ctx.fillRect(0, 0, this.cols * this.blockSize, this.rows * this.blockSize); }
  drawGrid() {
    for (let r = 0; r < this.rows; r++)
      for (let c = 0; c < this.cols; c++)
        if (this.blockColor[r][c] !== this.backColor) this.paintSquare(r, c, this.blockColor[r][c]);
  }
  paint() { this.eraseGrid(); this.drawGrid(); }
  paintShape(shape, color) { shape.points.forEach(p => this.paintSquare(p.y, p.x, color)); }
  draw(shape) { this.paintShape(shape, shape.fillColor); }
  erase(shape) { this.paintShape(shape, this.backColor); }
  isPosValid(points) {
    return points.every(p =>
      p.x >= 0 && p.x < this.cols && p.y < this.rows && (p.y < 0 || this.blockColor[p.y][p.x] === this.backColor));
  }
  addShape(shape) {
    for (const p of shape.points) {
      if (p.y < 0) return false;
      this.blockColor[p.y][p.x] = shape.fillColor;
    }
    return true;
  }
  // üí• NUEVO: limpiar filas completas
  clearFullRows() {
    let cleared = 0;
    for (let r = this.rows -1; r >= 0; r--) {
      if (this.blockColor[r].every(color => color !== this.backColor)) {
        this.blockColor.splice(r,1);
        this.blockColor.unshift(Array(this.cols).fill(this.backColor));
        cleared++;
        r++; // volver a comprobar esta fila
      }
    }
    return cleared;
  }
}

class Game {
  constructor(canvas) {
    const isDark = document.documentElement.classList.contains("dark");
    const backColor = isDark ? "#1f2937" : "#f3f4f6";
    this.canvas = canvas;
    this.grid = new Grid(20, 10, 20, backColor, canvas);
    this.timer = null;
    this.baseSpeed = 500;
    this.speed = this.baseSpeed;
    this.phase = "playing";
    this.score = 0;
    this.level = 1;
    this.boundKeyHandler = this.keyHandler.bind(this);
    window.addEventListener("keydown", this.boundKeyHandler, { passive: false });
    this.currentShape = this.getRandomShape(this.grid.cols);
  }

  getRandomShape(cols) {
    const shapes = [TShape, IShape, OShape, LShape, JShape, SShape, ZShape];
    const RandomShape = shapes[Math.floor(Math.random() * shapes.length)];
    return new RandomShape(cols);
  }

  start() { this.loop(); }
  loop() {
    this.timer = window.setInterval(() => {
      if (this.phase !== "playing") return;
      let nextPos = this.currentShape.drop();
      if (this.grid.isPosValid(nextPos)) {
        this.currentShape.setPos(nextPos);
      } else {
        const added = this.grid.addShape(this.currentShape);
        if (!added) {
          this.gameOver();
          return;
        }
        let cleared = this.grid.clearFullRows();
        if (cleared > 0) {
          this.score += cleared * 100; // üí• puntos extra por filas limpias
        } else {
          this.score += 10;
        }
        document.getElementById("score").innerText = this.score;
        this.updateLevel();
        this.currentShape = this.getRandomShape(this.grid.cols);
      }
      this.render();
    }, this.speed);
  }
  updateLevel() {
    const newLevel = Math.floor(this.score / 100) + 1;
    if (newLevel > this.level) {
      this.level = newLevel;
      this.speed = Math.max(100, this.baseSpeed - (this.level - 1) * 50);
      clearInterval(this.timer);
      this.loop();
    }
    document.getElementById("level").innerText = this.level;
  }
  render() { this.grid.paint(); this.grid.draw(this.currentShape); }
  keyHandler(e) {
    let points;
    switch (e.key) {
      case "ArrowLeft": points = this.currentShape.moveLeft(); break;
      case "ArrowRight": points = this.currentShape.moveRight(); break;
      case "ArrowUp": points = this.currentShape.rotate(true); break;
      case "ArrowDown":
        points = this.currentShape.drop();
        while (this.grid.isPosValid(points)) {
          this.currentShape.setPos(points);
          points = this.currentShape.drop();
        }
        const added = this.grid.addShape(this.currentShape);
        if (!added) {
          this.gameOver();
          return;
        }
        let cleared = this.grid.clearFullRows();
        if (cleared > 0) {
          this.score += cleared * 100;
        } else {
          this.score += 10;
        }
        document.getElementById("score").innerText = this.score;
        this.updateLevel();
        this.currentShape = this.getRandomShape(this.grid.cols);
        break;
    }
    if (points && this.grid.isPosValid(points)) this.currentShape.setPos(points);
    this.render();
  }
  gameOver() {
    this.phase = "over";
    clearInterval(this.timer);
    const message = document.getElementById("floatingMessage");
    if (message) message.innerText = "üí• GAME OVER üîÑ";
  }
  stop() {
    clearInterval(this.timer);
    window.removeEventListener("keydown", this.boundKeyHandler);
  }
}

let gameInstance;
window.addEventListener("DOMContentLoaded", () => {
  const openBtn = document.getElementById("openModal");
  const modal = document.getElementById("tetrisModal");
  const container = document.getElementById("tetrisContainer");

  openBtn.addEventListener("click", () => {
    modal.classList.remove("hidden");
    document.body.style.overflow = "hidden";
    container.innerHTML = `
      <canvas id="gameCanvas" width="200" height="400" class="w-full h-full block"></canvas>
      <div id="floatingMessage"
        class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-28 text-center bg-white dark:bg-gray-700 text-black dark:text-white font-bold py-1 px-2 rounded">
      </div>`;
    const canvas = document.getElementById("gameCanvas");
    if (gameInstance) gameInstance.stop();
    gameInstance = new Game(canvas);
    gameInstance.start();
    document.getElementById("score").innerText = 0;
    document.getElementById("level").innerText = 1;

    document.getElementById("btnLeft").onclick = () => gameInstance.keyHandler({ key: "ArrowLeft" });
    document.getElementById("btnRight").onclick = () => gameInstance.keyHandler({ key: "ArrowRight" });
    document.getElementById("btnRotate").onclick = () => gameInstance.keyHandler({ key: "ArrowUp" });
    document.getElementById("btnDown").onclick = () => gameInstance.keyHandler({ key: "ArrowDown" });
    document.getElementById("btnReset").onclick = () => {
      gameInstance.stop();
      gameInstance = new Game(canvas);
      gameInstance.start();
      document.getElementById("score").innerText = 0;
      document.getElementById("level").innerText = 1;
      document.getElementById("floatingMessage").innerText = "";
    };
  });

  document.addEventListener("click", (event) => {
    if (event.target && event.target.id === "closeModal") {
      modal.classList.add("hidden");
      document.body.style.overflow  = '';
      if (gameInstance) {
        gameInstance.stop();
        gameInstance = null;
      }
      container.innerHTML = "";
    }
  });

  document.addEventListener("keydown", (event) => {
    if (event.key === "F2") {
      const canvas = document.querySelector("#tetrisContainer canvas");
      if (canvas) {
        if (gameInstance) gameInstance.stop();
        gameInstance = new Game(canvas);
        gameInstance.start();
        document.getElementById("score").innerText = 0;
        document.getElementById("level").innerText = 1;
        document.getElementById("floatingMessage").innerText = "";
      }
    }
  });
});
</script>

